<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Icon Display Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <!-- https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/ -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.min.js"></script>
  <script>
    const MouseButton = Object.freeze({
      NONE: -1,
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2
    });

    let container;

    let camera, scene, renderer;

    let mouse = MouseButton.NONE;
    let mouseX = 0, mouseY = 0;

    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;

    let icon;
    let pivot;
    let mesh;
    let geometry;
    let animData;
    let frame = 0;

    init();
    animate();

    function init()
    {
      container = document.createElement('div');
      document.body.appendChild(container);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 2000);
      camera.position.z = 2;

      // scene

      scene = new THREE.Scene();

      //const axesHelper = new THREE.AxesHelper( 5 );
      //scene.add(axesHelper);

      const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 0.8);
      camera.add(pointLight);
      scene.add(camera);

      // manager

      function loadModel()
      {
        icon.traverse(function (child) {
          if (child.isMesh) {
            mesh = child;
            geometry = mesh.geometry;
            child.material.map = texture;
          }
        });

        // Detect "center" of icon and place it on a pivot by there.
        var boundingBox = new THREE.Box3().setFromObject(icon)
        boundingBox.getCenter(icon.position);
        icon.position.multiplyScalar(-1);

        pivot = new THREE.Group();
        scene.add(pivot);
        pivot.add(icon);
      }

      const manager = new THREE.LoadingManager(loadModel);

      // texture
      const textureLoader = new THREE.TextureLoader(manager);
      const texture = textureLoader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg');
      texture.colorSpace = THREE.SRGBColorSpace;

      // model

      function onProgress(xhr)
      {
        if (xhr.lengthComputable) {

          const percentComplete = xhr.loaded / xhr.total * 100;
          console.log('model ' + Math.round(percentComplete, 2) + '% downloaded');

        }
      }

      function onError() 
      {

      }

      fetch('test.anim')
        .then(response => response.json())
        .then(data => {
          // Do something with the deserialized data here
          animData = data;
        });

      const loader = new THREE.OBJLoader(manager);
      loader.load('http://127.0.0.1:5500/test.obj', function (obj)
      {
        icon = obj;
      }, onProgress, onError);

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      document.addEventListener('mousedown', onMouseDown, false);
      document.addEventListener('mouseup', onMouseUp, false);
      document.addEventListener('contextmenu', event => event.preventDefault());
      document.addEventListener('mousemove', onDocumentMouseMove);
      document.addEventListener('mousewheel', onDocumentMouseWheel);

      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize()
    {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseDown(event) 
    {
      event.preventDefault();
      mouse = event.button;
      mouseX = event.clientX;
      mouseY = event.clientY;
    }
    
    function onMouseUp(event) 
    {
      event.preventDefault();
      mouse = MouseButton.NONE;
    }
    
    function onDocumentMouseMove(event)
    {
      if (mouse == MouseButton.NONE) {
        document.body.style.cursor = "auto";
        return;
      }
      else if (mouse == MouseButton.LEFT || mouse == MouseButton.RIGHT) {
        event.preventDefault();
        var deltaX = event.clientX - mouseX;
        var deltaY = event.clientY - mouseY;
        mouseX = event.clientX;
        mouseY = event.clientY;

        if (mouse == MouseButton.LEFT) {
          document.body.style.cursor = "grabbing";
          rotateScene(deltaX, deltaY);
        }
        else if (mouse == MouseButton.RIGHT) {
          document.body.style.cursor = "move";
          moveScene(deltaX, deltaY);
        }
      }
    }

    function rotateScene(deltaX, deltaY) {
      pivot.rotation.y += deltaX / 100;
      pivot.rotation.x += deltaY / 100;
    }

    function moveScene(deltaX, deltaY) {
      pivot.position.x += deltaX / 1000;
      pivot.position.y += -deltaY / 1000;
    }

    function onDocumentMouseWheel(event)
    {
      camera.position.z += event.deltaY / 500;
    }

    function animate()
    {
      requestAnimationFrame(animate);
      render();
    }

    var tet = 0;

    function render()
    {
      tet += 1;
      
      if (mesh && (tet % 60 == 0)) // If mesh is loaded every 60 frames.
      {
        console.log('next frame')
        frame += 1;
        frame %= animData.vertex_data.length;
        // Get the position attribute
        const positionAttribute = geometry.attributes.position;
        
        // Modify the positions of the vertices
        for (let i = 0; i < positionAttribute.count; i++) {
          [x, y, z] = animData.vertex_data[frame].slice(i * 3, (i * 3) + 3);
          x = -x
          y = -y
          //z = -z
          positionAttribute.setXYZ(i, x, y, z);
        }
        
        positionAttribute.needsUpdate = true
      }

      renderer.render(scene, camera);
    }
  </script>
</body>

</html>