<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>My Three.js Canvas</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <!-- https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/ -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.min.js"></script>
  <script>
    let container;

    let camera, scene, renderer;

    let mouseDown = false;
    let mouseX = 0, mouseY = 0;

    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;

    let icon;
    let pivot;

    init();
    animate();

    function init()
    {
      container = document.createElement('div');
      document.body.appendChild(container);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 2000);
      camera.position.z = 2;

      // scene

      scene = new THREE.Scene();

      //const axesHelper = new THREE.AxesHelper( 5 );
      //scene.add(axesHelper);

      const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 0.8);
      camera.add(pointLight);
      scene.add(camera);

      // manager

      function loadModel()
      {
        icon.traverse(function (child) {
          if (child.isMesh) {
            child.material.map = texture;
          }
        });

        // Detect "center" of icon and place it on a pivot by there.
        var boundingBox = new THREE.Box3().setFromObject(icon)
        boundingBox.getCenter(icon.position);
        icon.position.multiplyScalar(-1);

        pivot = new THREE.Group();
        scene.add(pivot);
        pivot.add(icon);
      }

      const manager = new THREE.LoadingManager(loadModel);

      // texture
      const textureLoader = new THREE.TextureLoader(manager);
      const texture = textureLoader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg');
      texture.colorSpace = THREE.SRGBColorSpace;

      // model

      function onProgress(xhr)
      {
        if (xhr.lengthComputable) {

          const percentComplete = xhr.loaded / xhr.total * 100;
          console.log('model ' + Math.round(percentComplete, 2) + '% downloaded');

        }
      }

      function onError() 
      {

      }

      const loader = new THREE.OBJLoader(manager);
      loader.load('http://127.0.0.1:5500/test.obj', function (obj)
      {
        icon = obj;
      }, onProgress, onError);

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      document.addEventListener('mousedown', onMouseDown);
      document.addEventListener('mouseup', onMouseUp);
      document.addEventListener('mousemove', onDocumentMouseMove);
      document.addEventListener('mousewheel', onDocumentMouseWheel);

      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize()
    {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseDown(event) 
    {
      event.preventDefault();
      mouseDown = true;
      mouseX = event.clientX;
      mouseY = event.clientY;
      document.body.style.cursor = "pointer";
    }
    
    function onMouseUp(event) 
    {
      event.preventDefault();
      mouseDown = false;
      document.body.style.cursor = "auto";
    }

    function onDocumentMouseMove(event)
    {
      if (!mouseDown) {
        return;
      }

      event.preventDefault();

      var deltaX = event.clientX - mouseX;
      var deltaY = event.clientY - mouseY;
      mouseX = event.clientX;
      mouseY = event.clientY;
      rotateScene(deltaX, deltaY);
    }

    function rotateScene(deltaX, deltaY) {
      pivot.rotation.y += deltaX / 100;
      pivot.rotation.x += deltaY / 100;
    }

    function onDocumentMouseWheel(event)
    {
      camera.position.z += event.deltaY / 500;
    }

    function animate()
    {
      requestAnimationFrame(animate);
      render();
    }

    function render()
    {
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>